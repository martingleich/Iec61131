Inline VAR declarations
	Syntax as Statement:
		VAR <identifier>;
		VAR <identifier> : <Type>;
		VAR <identifier> := <Expression>;
		VAR <identifier> : <Type> := <Expression>;
	Syntax as output:
		Call(outArg => VAR <identifier>)
		Call(outArg => VAR <identifier> : <Type>)
	Syntax as LoopIndex
		FOR VAR <identifier> := <expr> TO <upper>
		FOR VAR <identifier> : <Type> := <expr> TO <upper>

	If no type is given, the type is infered from the expression
	All these variables are temporary variables.
	All these variables are scoped to the smaller sourounding block
	Shadowing of other temporary or parameter variables is not allowed.
	Variables are marked as used at the beginning of the block(seperate path),
		and are to be typed later(if not type is given in the syntax)
		initially they have the error type.
	Using a variable before it will be declared, is a error.
	A variable will be marked as declared when it is definitly declared, this depends on the kind of declaration:
		Statement: After statement
		Call-output: After the call
		LoopIndex: Before the first statement of the loop, but after the BY-Clause

	Step1:
		Parsing
			Statement
			Call
			Loop
		Binding
			Allow LocalVariable to be late declared and late typed.
			When binding a block collect all declared variables inside and return them to the outside for flow analysis.
			Bind the block
			...
			


Add find expression at source span
Add find bound expression at source span

Add CASE statement
Add Exception System
Add safe ENUMs
Add simple x64 codegenerator

Simple incremental compile
Add bound node types for symbols, this would give a working space for the multiple compile-phases and allow a details lookup.
LateLanguageUpdates
Strings
Durations
	Add casts:
		TIME->LTIME
	Add scalar operations:
		(L)TIME * ANY_NUM -> (L)TIME
		(L)TIME / ANY_NUM -> (L)TIME
		(L)TIME / (L)TIME -> (L)REAL
		(L)TIME MOD (L)TIME -> (L)TIME
